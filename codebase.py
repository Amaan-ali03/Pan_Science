# -*- coding: utf-8 -*-
"""Codebase.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/188GZJBmTigz7uMQArR5grKSmXF_wqwm3
"""

# Importing necessary libraries
import re
import csv
import os
from typing import Optional, Tuple, Dict

class NameDisambiguator:
    def __init__(self, database_path: str = "company_data.csv"):
        """Load the company database from a CSV file if it exists."""
        if not os.path.exists(database_path):
            raise FileNotFoundError(f"Uh-oh! Couldn't find '{database_path}'. Double-check the file path.")

        self.company_db = self._load_company_database(database_path)

    def _load_company_database(self, db_path: str) -> Dict[str, Dict[str, str]]:
        """Reads the CSV and organizes data in a way that allows quick lookup."""
        company_data = {}

        try:
            with open(db_path, mode='r', newline='', encoding='utf-8') as file:
                csv_reader = csv.DictReader(file)

                for row in csv_reader:
                    # Get rid of leading/trailing spaces
                    name = row['Company Name'].strip()
                    ticker = row['Ticker Symbol'].strip().lower()  # Store tickers in lowercase for easy matching
                    exchange = row['Exchange Name'].strip()
                    aliases = [alias.strip().lower() for alias in row.get('Aliases', '').split(',') if alias.strip()]

                    # Store company info in multiple ways to allow flexible searching
                    entry = {'company_name': name, 'ticker_symbol': ticker.upper(), 'exchange_name': exchange}

                    company_data[name.lower()] = entry
                    company_data[ticker] = entry
                    for alias in aliases:
                        company_data[alias] = entry  # Allow searching by alias too

        except Exception as e:
            print(f"Error reading company database: {e}")

        return company_data

    def parse_structured_input(self, input_text: str) -> Optional[Tuple[str, str, str]]:
        """Handles input like 'NASDAQ:AAPL' where exchange and ticker are explicitly mentioned."""
        if ':' in input_text:
            parts = input_text.split(':')
            if len(parts) == 2:
                exchange, ticker = parts[0].strip(), parts[1].strip().lower()

                if ticker in self.company_db:
                    company = self.company_db[ticker]
                    return company['company_name'], company['ticker_symbol'], company['exchange_name']

        return None  # No structured match found

    def parse_unstructured_input(self, input_text: str) -> Optional[Tuple[str, str, str]]:
        """Handles input like 'Tesla' or 'Google' and tries to match it to a company in the database."""
        key = input_text.strip().lower()
        if key in self.company_db:
            company = self.company_db[key]
            return company['company_name'], company['ticker_symbol'], company['exchange_name']

        return None  # No unstructured match found

    def disambiguate(self, input_text: str) -> Optional[Tuple[str, str, str]]:
        """Tries to resolve input as either structured (exchange:ticker) or unstructured (company name/alias)."""
        return self.parse_structured_input(input_text) or self.parse_unstructured_input(input_text)

if __name__ == "__main__":
    try:
        # Let's try resolving some company names and tickers!
        disambiguator = NameDisambiguator("company_data.csv")

        test_cases = [
            "NASDAQ:AAPL",  # Should return Apple Inc.
            "Tesla",        # Should return Tesla, Inc.
            "NYSE:MSFT",    # Microsoft, expected to match
            "Google",       # Should return Alphabet Inc.
            "SomeRandomText"  # Should fail
        ]

        for query in test_cases:
            result = disambiguator.disambiguate(query)
            if result:
                print(f"Input: {query} \n Company Name: {result[0]}, Ticker Symbol: {result[1]}, Exchange Name: {result[2]}")
            else:
                print(f"Input: {query} \n No match found.")
    except FileNotFoundError as e:
        print(e)

